{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started \u00b6 Gitsheets is the toolkit for distributed recordkeeping that lives inside Git. Overview \u00b6 To prepare a repository for use with Gitsheets, all you need is a way to map a named sheet to a tree of normalized TOML files (containing one record per file). Natural keys \u00b6 Gitsheets works best with records that have natural keys , and doesn\u2019t provide any mechanism out-of-the-box for assigning keys randomly/sequentially. If your records don\u2019t yet contain any unique identifier, assign your own somehow before loading them into a git sheet. Declare a sheet \u00b6 To declare a sheet named todos for example, create a file in your git repository at .gitsheets/todos.toml : [gitsheet] root = \"data/todos\" path = \"user-${{ userId }}/${{ id }}\" This configuration declares two essential things about the todos sheet: gitsheet.root declares the root path within the repository containing all records for this sheet all .toml files under this path are considered to declare records the path may contain any number of / s to nest the sheet\u2019s root gitsheet.path declares a template for finding the path to a given record ${{ expression }} path components can use arbitrary javascript The todos sheet can now be upserted and queried by any Gitsheets interface. Upsert records \u00b6 Using the git sheet command line interface Using the gitsheets NodeJS module Coming soon: Using the Gitsheets UI Record format \u00b6 Records are stored one-per file in TOML format with keys sorted alphabetically: completed = false id = 181 title = \"ut cupiditate sequi aliquam fuga maiores\" userId = 10 The goals of this serialization are to: Consistently render records to a normal form, such that identical record content will produce the same content hash Be decently readable in text and diff form Be easy to hand-edit Store basic data types consistently Generate minimal diff noise Querying records \u00b6 Path templates are indexes","title":"Getting Started"},{"location":"#getting-started","text":"Gitsheets is the toolkit for distributed recordkeeping that lives inside Git.","title":"Getting Started"},{"location":"#overview","text":"To prepare a repository for use with Gitsheets, all you need is a way to map a named sheet to a tree of normalized TOML files (containing one record per file).","title":"Overview"},{"location":"#natural-keys","text":"Gitsheets works best with records that have natural keys , and doesn\u2019t provide any mechanism out-of-the-box for assigning keys randomly/sequentially. If your records don\u2019t yet contain any unique identifier, assign your own somehow before loading them into a git sheet.","title":"Natural keys"},{"location":"#declare-a-sheet","text":"To declare a sheet named todos for example, create a file in your git repository at .gitsheets/todos.toml : [gitsheet] root = \"data/todos\" path = \"user-${{ userId }}/${{ id }}\" This configuration declares two essential things about the todos sheet: gitsheet.root declares the root path within the repository containing all records for this sheet all .toml files under this path are considered to declare records the path may contain any number of / s to nest the sheet\u2019s root gitsheet.path declares a template for finding the path to a given record ${{ expression }} path components can use arbitrary javascript The todos sheet can now be upserted and queried by any Gitsheets interface.","title":"Declare a sheet"},{"location":"#upsert-records","text":"Using the git sheet command line interface Using the gitsheets NodeJS module Coming soon: Using the Gitsheets UI","title":"Upsert records"},{"location":"#record-format","text":"Records are stored one-per file in TOML format with keys sorted alphabetically: completed = false id = 181 title = \"ut cupiditate sequi aliquam fuga maiores\" userId = 10 The goals of this serialization are to: Consistently render records to a normal form, such that identical record content will produce the same content hash Be decently readable in text and diff form Be easy to hand-edit Store basic data types consistently Generate minimal diff noise","title":"Record format"},{"location":"#querying-records","text":"Path templates are indexes","title":"Querying records"},{"location":"advanced-layouts/","text":"Advanced repository layouts \u00b6 The standard layout for Gitsheets in a repository is to place a .gitsheets/ tree at the root of the repository, and reference data trees from there. More advanced layouts may be desired though, either to accommodate multiple independent data sets within the same repository, or to logically position a subcomponent within a monorepo. Nested roots \u00b6 A nested root can be configured to use a .gitsheets/ tree positioned within some sub-path of a repository. All roots and paths configured for the sheets declared within will be relative to the parent of the .gitsheets/ tree. For example, you might be using Gitsheets to store static fixture data for a software project\u2019s testing process. You could declare sheets at fixtures/.gitsheets/*.toml and keep everything contained within fixtures/ by configuring a root of fixtures : fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u2514\u2500\u2500 users.toml \u2514\u2500\u2500 users/**/*.toml An alternative root may be configured via environment variable: export GITSHEETS_ROOT = fixtures git sheet query users Or overridden via the --root argument to most commands: git sheet query users --root = fixtures If both are provided, the command line argument overrides the environment variable. Data prefixes \u00b6 It is also possible to store multiple independent data sets that share the same .gitsheets/ declarations by configuring a prefix . Continuing the example from the previous section, you might want to also have several different versions of your data set to use in testing different scenarios, all sharing the same schema: fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u251c\u2500\u2500 projects.toml \u2502 \u2514\u2500\u2500 users.toml \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 projects/**/*.toml \u2502 \u2514\u2500\u2500 users/**/*.toml \u2514\u2500\u2500 scenarios/ \u251c\u2500\u2500 double-growth/ \u2502 \u2514\u2500\u2500 projects/**/*.toml \u2514\u2500\u2500 half-growth/ \u2514\u2500\u2500 projects/**/*.toml As with nested roots, prefixes can be configured either environmentally: export GITSHEETS_ROOT = fixtures export GITSHEETS_PREFIX = scenarios/double-growth git sheet query projects Or overridden via the --prefix argument to most commands: git sheet query users --root = fixtures --prefix = scenarios/double-growth","title":"Advanced repository layouts"},{"location":"advanced-layouts/#advanced-repository-layouts","text":"The standard layout for Gitsheets in a repository is to place a .gitsheets/ tree at the root of the repository, and reference data trees from there. More advanced layouts may be desired though, either to accommodate multiple independent data sets within the same repository, or to logically position a subcomponent within a monorepo.","title":"Advanced repository layouts"},{"location":"advanced-layouts/#nested-roots","text":"A nested root can be configured to use a .gitsheets/ tree positioned within some sub-path of a repository. All roots and paths configured for the sheets declared within will be relative to the parent of the .gitsheets/ tree. For example, you might be using Gitsheets to store static fixture data for a software project\u2019s testing process. You could declare sheets at fixtures/.gitsheets/*.toml and keep everything contained within fixtures/ by configuring a root of fixtures : fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u2514\u2500\u2500 users.toml \u2514\u2500\u2500 users/**/*.toml An alternative root may be configured via environment variable: export GITSHEETS_ROOT = fixtures git sheet query users Or overridden via the --root argument to most commands: git sheet query users --root = fixtures If both are provided, the command line argument overrides the environment variable.","title":"Nested roots"},{"location":"advanced-layouts/#data-prefixes","text":"It is also possible to store multiple independent data sets that share the same .gitsheets/ declarations by configuring a prefix . Continuing the example from the previous section, you might want to also have several different versions of your data set to use in testing different scenarios, all sharing the same schema: fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u251c\u2500\u2500 projects.toml \u2502 \u2514\u2500\u2500 users.toml \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 projects/**/*.toml \u2502 \u2514\u2500\u2500 users/**/*.toml \u2514\u2500\u2500 scenarios/ \u251c\u2500\u2500 double-growth/ \u2502 \u2514\u2500\u2500 projects/**/*.toml \u2514\u2500\u2500 half-growth/ \u2514\u2500\u2500 projects/**/*.toml As with nested roots, prefixes can be configured either environmentally: export GITSHEETS_ROOT = fixtures export GITSHEETS_PREFIX = scenarios/double-growth git sheet query projects Or overridden via the --prefix argument to most commands: git sheet query users --root = fixtures --prefix = scenarios/double-growth","title":"Data prefixes"},{"location":"canonical-sorting/","text":"Canonical sorting \u00b6 Gitsheets tries to get the most out of its git foundations by rendering records to file in as much a \u201cnormal\u201d form as possible. This means that we try to make the \u201csame\u201d data produce the same file byte-for-byte, even when the input is formatted differently. One thing Gitsheets does automatically to help normalize records is sorting keys alphabetically, so that both { first_name: \"Grade\", last_name: \"Hopper\" } and { last_name: \"Hopper\", first_name \"Grace\" } render as identical records. Gitsheets can do this because it does not guarantee the order of keyed values be preserved. However, Gitsheets does not take the same liberty with arrays, because not being able to store ordered lists would be a significant loss of functionality. In some applications, the order of elements in a list may be significant so order needs to be preserved by default. For applications where the order of a given array field is not significant though, the lack of sorting means you could have two version of a record that mean the same thing but look changed because an array ended up in a different order. For these cases, you may define a sort for a field in the .gitsheets/*.toml sheet declaration. This sort will be applied every time a version of the record is being normalized for writing to file to help reduce how often records that mean the same thing look changed to the versioning system. Sorting by expression \u00b6 You can define an arbitrary JavaScript expression for sorting a given field: [gitsheet.fields.relationships] sort = ''' if (a.kind < b.kind) return -1; if (a.kind > b.kind) return 1; if (a.label < b.label) return -1; if (a.label > b.label) return 1; return 0; ''' Sorting by configuration \u00b6 In this simple case, the same sort can be achieved via a table-based configuration: [gitsheet.fields.relationships] sort = { kind = 'ASC' , label = 'ASC' } Or via an array-based configuration: [gitsheet.fields.relationships] sort = [ 'kind', 'label' ]","title":"Canonical sorting"},{"location":"canonical-sorting/#canonical-sorting","text":"Gitsheets tries to get the most out of its git foundations by rendering records to file in as much a \u201cnormal\u201d form as possible. This means that we try to make the \u201csame\u201d data produce the same file byte-for-byte, even when the input is formatted differently. One thing Gitsheets does automatically to help normalize records is sorting keys alphabetically, so that both { first_name: \"Grade\", last_name: \"Hopper\" } and { last_name: \"Hopper\", first_name \"Grace\" } render as identical records. Gitsheets can do this because it does not guarantee the order of keyed values be preserved. However, Gitsheets does not take the same liberty with arrays, because not being able to store ordered lists would be a significant loss of functionality. In some applications, the order of elements in a list may be significant so order needs to be preserved by default. For applications where the order of a given array field is not significant though, the lack of sorting means you could have two version of a record that mean the same thing but look changed because an array ended up in a different order. For these cases, you may define a sort for a field in the .gitsheets/*.toml sheet declaration. This sort will be applied every time a version of the record is being normalized for writing to file to help reduce how often records that mean the same thing look changed to the versioning system.","title":"Canonical sorting"},{"location":"canonical-sorting/#sorting-by-expression","text":"You can define an arbitrary JavaScript expression for sorting a given field: [gitsheet.fields.relationships] sort = ''' if (a.kind < b.kind) return -1; if (a.kind > b.kind) return 1; if (a.label < b.label) return -1; if (a.label > b.label) return 1; return 0; '''","title":"Sorting by expression"},{"location":"canonical-sorting/#sorting-by-configuration","text":"In this simple case, the same sort can be achieved via a table-based configuration: [gitsheet.fields.relationships] sort = { kind = 'ASC' , label = 'ASC' } Or via an array-based configuration: [gitsheet.fields.relationships] sort = [ 'kind', 'label' ]","title":"Sorting by configuration"},{"location":"path-templates/","text":"Path templates \u00b6 Path templates are the key to how Gitsheets works. They define how each sheet maps records into a tree of files. In addition to teaching Gitsheets how to store records, path templates also inform how they are queried. Gitsheets attempts to load as little of the tree as possible while executing a query by rendering the path from left to right against the query. This means that essentially, your path template is also your indexing and sharding strategy. This has little practical performance implication for sets of records in the 10s and 100s, but can become significant beyond that. Single-field unique key \u00b6 The simplest case is one where each record already has a single unique text field. .gitsheets/users.toml [gitsheet] root = \"users\" path = \"${{ username }}\" users/GrandmaCOBOL.toml first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"users\" path = \"${{ username }}\"' > .gitsheets/users.toml Upsert a user: git sheet upsert users '{ \"username\": \"GrandmaCOBOL\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }' Query a user: git sheet query users --filter.username = GrandmaCOBOL Multi-field unique key \u00b6 If one field is not enough to create a unique path, a composite key can be configured by combining multiple path components: .gitsheets/domain-users.toml [gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\" domain-users/af.mil/GrandmaCOBOL.toml domain = \"af.mil\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" domain-users/yale.edu/GrandmaCOBOL.toml domain = \"yale.edu\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the domain-users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\"' > .gitsheets/domain-users.toml Upsert multiple users: git sheet upsert domain-users '[ { \"username\": \"GrandmaCOBOL\", \"domain\": \"yale.edu\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }, { \"username\": \"GrandmaCOBOL\", \"domain\": \"af.mil\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" } ]' Query multiple users: git sheet query users --filter.username = GrandmaCOBOL Query unique user by domain: git sheet query users --filter.username = GrandmaCOBOL --filter.domain = af.mil Sharding paths \u00b6 Path components need not contribute to the path\u2019s uniqueness, the can also be used just to organize records either for easier human browsing or to spread the records over multiple subtrees for improved query performance. Smaller trees can be loaded and searched faster, and any fields you\u2019re likely to often filter queries with can be acted on without loading and parsing the record if they\u2019re part of the path: .gitsheets/students.toml [gitsheet] root = \"students\" path = \"${{ graduation_year }}/${{ status }}/${{ student_id }}\" Dynamically sharding paths \u00b6 Because TOML has an explicit date type, and arbitrary JavaScript expressions can be used in path templates, you can do something like this to organize records by date: .gitsheets/blog-posts.toml [gitsheet] root = \"blog-posts\" path = \"${{ published_at.getYear() }}/${{ published_at.getMonth() }}/${{ published_at.getDate() }}/${{ slug }}\" Annotated paths \u00b6 Prefixes, suffixes, and static path components can be used to add clarity for human readers: .gitsheets/todos.toml [gitsheet] root = \"todos\" path = \"by-user/user-${{ userId }}/${{ id }}\" Nested path fields \u00b6 If a field may contain / characters internally, they can be used to build paths: .gitsheets/content.toml [gitsheet] root = \"content\" path = \"${{ path/** }}\"","title":"Path templates"},{"location":"path-templates/#path-templates","text":"Path templates are the key to how Gitsheets works. They define how each sheet maps records into a tree of files. In addition to teaching Gitsheets how to store records, path templates also inform how they are queried. Gitsheets attempts to load as little of the tree as possible while executing a query by rendering the path from left to right against the query. This means that essentially, your path template is also your indexing and sharding strategy. This has little practical performance implication for sets of records in the 10s and 100s, but can become significant beyond that.","title":"Path templates"},{"location":"path-templates/#single-field-unique-key","text":"The simplest case is one where each record already has a single unique text field. .gitsheets/users.toml [gitsheet] root = \"users\" path = \"${{ username }}\" users/GrandmaCOBOL.toml first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"users\" path = \"${{ username }}\"' > .gitsheets/users.toml Upsert a user: git sheet upsert users '{ \"username\": \"GrandmaCOBOL\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }' Query a user: git sheet query users --filter.username = GrandmaCOBOL","title":"Single-field unique key"},{"location":"path-templates/#multi-field-unique-key","text":"If one field is not enough to create a unique path, a composite key can be configured by combining multiple path components: .gitsheets/domain-users.toml [gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\" domain-users/af.mil/GrandmaCOBOL.toml domain = \"af.mil\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" domain-users/yale.edu/GrandmaCOBOL.toml domain = \"yale.edu\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the domain-users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\"' > .gitsheets/domain-users.toml Upsert multiple users: git sheet upsert domain-users '[ { \"username\": \"GrandmaCOBOL\", \"domain\": \"yale.edu\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }, { \"username\": \"GrandmaCOBOL\", \"domain\": \"af.mil\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" } ]' Query multiple users: git sheet query users --filter.username = GrandmaCOBOL Query unique user by domain: git sheet query users --filter.username = GrandmaCOBOL --filter.domain = af.mil","title":"Multi-field unique key"},{"location":"path-templates/#sharding-paths","text":"Path components need not contribute to the path\u2019s uniqueness, the can also be used just to organize records either for easier human browsing or to spread the records over multiple subtrees for improved query performance. Smaller trees can be loaded and searched faster, and any fields you\u2019re likely to often filter queries with can be acted on without loading and parsing the record if they\u2019re part of the path: .gitsheets/students.toml [gitsheet] root = \"students\" path = \"${{ graduation_year }}/${{ status }}/${{ student_id }}\"","title":"Sharding paths"},{"location":"path-templates/#dynamically-sharding-paths","text":"Because TOML has an explicit date type, and arbitrary JavaScript expressions can be used in path templates, you can do something like this to organize records by date: .gitsheets/blog-posts.toml [gitsheet] root = \"blog-posts\" path = \"${{ published_at.getYear() }}/${{ published_at.getMonth() }}/${{ published_at.getDate() }}/${{ slug }}\"","title":"Dynamically sharding paths"},{"location":"path-templates/#annotated-paths","text":"Prefixes, suffixes, and static path components can be used to add clarity for human readers: .gitsheets/todos.toml [gitsheet] root = \"todos\" path = \"by-user/user-${{ userId }}/${{ id }}\"","title":"Annotated paths"},{"location":"path-templates/#nested-path-fields","text":"If a field may contain / characters internally, they can be used to build paths: .gitsheets/content.toml [gitsheet] root = \"content\" path = \"${{ path/** }}\"","title":"Nested path fields"},{"location":"quick-demo/","text":"Quick demo \u00b6 Install the git sheet command \u00b6 npm install -g gitsheets Initialize a temporary git repository \u00b6 git init /tmp/gitsheets-demo cd /tmp/gitsheets-demo Declare a todos gitsheet \u00b6 mkdir -p .gitsheets echo -e '[gitsheet] root = \"todos\" path = \"user-${{ userId }}/${{ id }}\" ' > .gitsheets/todos.toml git add .gitsheets git commit -m \"feat: declare todos gitsheet\" Upsert records from an API \u00b6 curl https://jsonplaceholder.typicode.com/todos | git sheet upsert todos git commit -m \"data: import todos from API\" Query records via CLI \u00b6 gi t shee t query t odos -- f il ter .comple te d -- f orma t =csv > t odos.comple te d.csv","title":"Quick demo"},{"location":"quick-demo/#quick-demo","text":"","title":"Quick demo"},{"location":"quick-demo/#install-the-git-sheet-command","text":"npm install -g gitsheets","title":"Install the git sheet command"},{"location":"quick-demo/#initialize-a-temporary-git-repository","text":"git init /tmp/gitsheets-demo cd /tmp/gitsheets-demo","title":"Initialize a temporary git repository"},{"location":"quick-demo/#declare-a-todos-gitsheet","text":"mkdir -p .gitsheets echo -e '[gitsheet] root = \"todos\" path = \"user-${{ userId }}/${{ id }}\" ' > .gitsheets/todos.toml git add .gitsheets git commit -m \"feat: declare todos gitsheet\"","title":"Declare a todos gitsheet"},{"location":"quick-demo/#upsert-records-from-an-api","text":"curl https://jsonplaceholder.typicode.com/todos | git sheet upsert todos git commit -m \"data: import todos from API\"","title":"Upsert records from an API"},{"location":"quick-demo/#query-records-via-cli","text":"gi t shee t query t odos -- f il ter .comple te d -- f orma t =csv > t odos.comple te d.csv","title":"Query records via CLI"},{"location":"cli/","text":"Getting started \u00b6 npm install -g gitsheets-cli Or with Chef Habitat: hab pkg install jarvus/gitsheets","title":"Getting started"},{"location":"cli/#getting-started","text":"npm install -g gitsheets-cli Or with Chef Habitat: hab pkg install jarvus/gitsheets","title":"Getting started"},{"location":"cli/examples/","text":"Examples \u00b6 Add id based on file name \u00b6 In this example, shell scripting is used to go through a set of incomplete initial records and populate their ID from their filename: find issues skills statuses technologies -name '*.toml' | while read record_path ; do record_id = $( basename \" ${ record_path } \" .toml ) record_sheet = $( dirname \" ${ record_path } \" ) echo \"Initializing id= ${ record_id } for ${ record_path } in ${ record_sheet } \" git sheet read \" ${ record_path } \" \\ | jq \".id = \\\" ${ record_id } \\\"\" \\ | git sheet upsert \" ${ record_sheet } \" done","title":"Examples"},{"location":"cli/examples/#examples","text":"","title":"Examples"},{"location":"cli/examples/#add-id-based-on-file-name","text":"In this example, shell scripting is used to go through a set of incomplete initial records and populate their ID from their filename: find issues skills statuses technologies -name '*.toml' | while read record_path ; do record_id = $( basename \" ${ record_path } \" .toml ) record_sheet = $( dirname \" ${ record_path } \" ) echo \"Initializing id= ${ record_id } for ${ record_path } in ${ record_sheet } \" git sheet read \" ${ record_path } \" \\ | jq \".id = \\\" ${ record_id } \\\"\" \\ | git sheet upsert \" ${ record_sheet } \" done","title":"Add id based on file name"},{"location":"nodejs/","text":"Getting started \u00b6 npm install --save gitsheets","title":"Getting started"},{"location":"nodejs/#getting-started","text":"npm install --save gitsheets","title":"Getting started"}]}