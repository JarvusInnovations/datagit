{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started \u00b6 To prepare a repository for use with Gitsheets, all you need is a way to map a named sheet to a tree of normalized TOML files store one record per file. Natural keys \u00b6 Gitsheets works best with records that have natural keys , and doesn\u2019t provide any mechanism out-of-the-box for assigning keys randomly/sequentially. If your records don\u2019t yet contain any unique identifier, assign your own somehow before loading them into a git sheet. Declare a sheet \u00b6 To declare a sheet named todos , create a file in your git repository at .gitsheets/todos.toml : [gitsheet] root = \"data/todos\" path = \"user-${{ userId }}/${{ id }}\" This configuration declares two essential things about the todos sheet: gitsheet.root declares the root path within the repository containing all records for this sheet all .toml files under this path are considered to declare records the path may contain any number of / s to nest the sheet\u2019s root gitsheet.path declares a template for finding the path to a given record ${{ expression }} path components can use arbitrary javascript The todos sheet can now be upserted and queried by any Gitsheets interface. Upsert records \u00b6 Using the git sheet command line interface Using the gitsheets NodeJS module Coming soon: Using the Gitsheets UI Record format \u00b6 Records are stored one-per file in TOML format with keys sorted alphabetically: completed = false id = 181 title = \"ut cupiditate sequi aliquam fuga maiores\" userId = 10 The goals of this serialization are to: Consistently render records to a normal form, such that identical record content will produce the same content hash Be decently readable in text and diff form Be easy to hand-edit Store basic data types consistently Generate minimal diff noise Querying records \u00b6 Path templates are indexes","title":"Getting Started"},{"location":"#getting-started","text":"To prepare a repository for use with Gitsheets, all you need is a way to map a named sheet to a tree of normalized TOML files store one record per file.","title":"Getting Started"},{"location":"#natural-keys","text":"Gitsheets works best with records that have natural keys , and doesn\u2019t provide any mechanism out-of-the-box for assigning keys randomly/sequentially. If your records don\u2019t yet contain any unique identifier, assign your own somehow before loading them into a git sheet.","title":"Natural keys"},{"location":"#declare-a-sheet","text":"To declare a sheet named todos , create a file in your git repository at .gitsheets/todos.toml : [gitsheet] root = \"data/todos\" path = \"user-${{ userId }}/${{ id }}\" This configuration declares two essential things about the todos sheet: gitsheet.root declares the root path within the repository containing all records for this sheet all .toml files under this path are considered to declare records the path may contain any number of / s to nest the sheet\u2019s root gitsheet.path declares a template for finding the path to a given record ${{ expression }} path components can use arbitrary javascript The todos sheet can now be upserted and queried by any Gitsheets interface.","title":"Declare a sheet"},{"location":"#upsert-records","text":"Using the git sheet command line interface Using the gitsheets NodeJS module Coming soon: Using the Gitsheets UI","title":"Upsert records"},{"location":"#record-format","text":"Records are stored one-per file in TOML format with keys sorted alphabetically: completed = false id = 181 title = \"ut cupiditate sequi aliquam fuga maiores\" userId = 10 The goals of this serialization are to: Consistently render records to a normal form, such that identical record content will produce the same content hash Be decently readable in text and diff form Be easy to hand-edit Store basic data types consistently Generate minimal diff noise","title":"Record format"},{"location":"#querying-records","text":"Path templates are indexes","title":"Querying records"},{"location":"advanced-layouts/","text":"Advanced repository layouts \u00b6 The standard layout for Gitsheets in a repository is to place a .gitsheets/ tree at the root of the repository, and reference data trees from there. More advanced layouts may be desired though, either to accommodate multiple independent data sets within the same repository, or to logically position a subcomponent within a monorepo. Nested roots \u00b6 A nested root can be configured to use a .gitsheets/ tree positioned within some sub-path of a repository. All roots and paths configured for the sheets declared within will be relative to the parent of the .gitsheets/ tree. For example, you might be using Gitsheets to store static fixture data for a software project\u2019s testing process. You could declare sheets at fixtures/.gitsheets/*.toml and keep everything contained within fixtures/ by configuring a root of fixtures : fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u2514\u2500\u2500 users.toml \u2514\u2500\u2500 users/**/*.toml An alternative root may be configured via environment variable: export GITSHEETS_ROOT = fixtures git sheet query users Or overridden via the --root argument to most commands: git sheet query users --root = fixtures If both are provided, the command line argument overrides the environment variable. Data prefixes \u00b6 It is also possible to store multiple independent data sets that share the same .gitsheets/ declarations by configuring a prefix . Continuing the example from the previous section, you might want to also have several different versions of your data set to use in testing different scenarios, all sharing the same schema: fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u251c\u2500\u2500 projects.toml \u2502 \u2514\u2500\u2500 users.toml \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 projects/**/*.toml \u2502 \u2514\u2500\u2500 users/**/*.toml \u2514\u2500\u2500 scenarios/ \u251c\u2500\u2500 double-growth/ \u2502 \u2514\u2500\u2500 projects/**/*.toml \u2514\u2500\u2500 half-growth/ \u2514\u2500\u2500 projects/**/*.toml As with nested roots, prefixes can be configured either environmentally: export GITSHEETS_ROOT = fixtures export GITSHEETS_PREFIX = scenarios/double-growth git sheet query projects Or overridden via the --prefix argument to most commands: git sheet query users --root = fixtures --prefix = scenarios/double-growth","title":"Advanced repository layouts"},{"location":"advanced-layouts/#advanced-repository-layouts","text":"The standard layout for Gitsheets in a repository is to place a .gitsheets/ tree at the root of the repository, and reference data trees from there. More advanced layouts may be desired though, either to accommodate multiple independent data sets within the same repository, or to logically position a subcomponent within a monorepo.","title":"Advanced repository layouts"},{"location":"advanced-layouts/#nested-roots","text":"A nested root can be configured to use a .gitsheets/ tree positioned within some sub-path of a repository. All roots and paths configured for the sheets declared within will be relative to the parent of the .gitsheets/ tree. For example, you might be using Gitsheets to store static fixture data for a software project\u2019s testing process. You could declare sheets at fixtures/.gitsheets/*.toml and keep everything contained within fixtures/ by configuring a root of fixtures : fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u2514\u2500\u2500 users.toml \u2514\u2500\u2500 users/**/*.toml An alternative root may be configured via environment variable: export GITSHEETS_ROOT = fixtures git sheet query users Or overridden via the --root argument to most commands: git sheet query users --root = fixtures If both are provided, the command line argument overrides the environment variable.","title":"Nested roots"},{"location":"advanced-layouts/#data-prefixes","text":"It is also possible to store multiple independent data sets that share the same .gitsheets/ declarations by configuring a prefix . Continuing the example from the previous section, you might want to also have several different versions of your data set to use in testing different scenarios, all sharing the same schema: fixtures/ \u251c\u2500\u2500 .gitsheets/ \u2502 \u251c\u2500\u2500 projects.toml \u2502 \u2514\u2500\u2500 users.toml \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 projects/**/*.toml \u2502 \u2514\u2500\u2500 users/**/*.toml \u2514\u2500\u2500 scenarios/ \u251c\u2500\u2500 double-growth/ \u2502 \u2514\u2500\u2500 projects/**/*.toml \u2514\u2500\u2500 half-growth/ \u2514\u2500\u2500 projects/**/*.toml As with nested roots, prefixes can be configured either environmentally: export GITSHEETS_ROOT = fixtures export GITSHEETS_PREFIX = scenarios/double-growth git sheet query projects Or overridden via the --prefix argument to most commands: git sheet query users --root = fixtures --prefix = scenarios/double-growth","title":"Data prefixes"},{"location":"path-templates/","text":"Path templates \u00b6 Path templates are the key to how Gitsheets works. They define how each sheet maps records into a tree of files. In addition to teaching Gitsheets how to store records, path templates also inform how they are queried. Gitsheets attempts to load as little of the tree as possible while executing a query by rendering the path from left to right against the query. This means that essentially, your path template is also your indexing and sharding strategy. This has little practical performance implication for sets of records in the 10s and 100s, but can become significant beyond that. Single-field unique key \u00b6 The simplest case is one where each record already has a single unique text field. .gitsheets/users.toml [gitsheet] root = \"users\" path = \"${{ username }}\" users/GrandmaCOBOL.toml first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"users\" path = \"${{ username }}\"' > .gitsheets/users.toml Upsert a user: git sheet upsert users '{ \"username\": \"GrandmaCOBOL\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }' Query a user: git sheet query users --filter.username = GrandmaCOBOL Multi-field unique key \u00b6 If one field is not enough to create a unique path, a composite key can be configured by combining multiple path components: .gitsheets/domain-users.toml [gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\" domain-users/af.mil/GrandmaCOBOL.toml domain = \"af.mil\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" domain-users/yale.edu/GrandmaCOBOL.toml domain = \"yale.edu\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the domain-users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\"' > .gitsheets/domain-users.toml Upsert multiple users: git sheet upsert domain-users '[ { \"username\": \"GrandmaCOBOL\", \"domain\": \"yale.edu\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }, { \"username\": \"GrandmaCOBOL\", \"domain\": \"af.mil\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" } ]' Query multiple users: git sheet query users --filter.username = GrandmaCOBOL Query unique user by domain: git sheet query users --filter.username = GrandmaCOBOL --filter.domain = af.mil Sharding paths \u00b6 Path components need not contribute to the path\u2019s uniqueness, the can also be used just to organize records either for easier human browsing or to spread the records over multiple subtrees for improved query performance. Smaller trees can be loaded and searched faster, and any fields you\u2019re likely to often filter queries with can be acted on without loading and parsing the record if they\u2019re part of the path: .gitsheets/students.toml [gitsheet] root = \"students\" path = \"${{ graduation_year }}/${{ status }}/${{ student_id }}\" Dynamically sharding paths \u00b6 Because TOML has an explicit date type, and arbitrary JavaScript expressions can be used in path templates, you can do something like this to organize records by date: .gitsheets/blog-posts.toml [gitsheet] root = \"blog-posts\" path = \"${{ published_at.getYear() }}/${{ published_at.getMonth() }}/${{ published_at.getDate() }}/${{ slug }}\" Annotated paths \u00b6 Prefixes, suffixes, and static path components can be used to add clarity for human readers: .gitsheets/todos.toml [gitsheet] root = \"todos\" path = \"by-user/user-${{ userId }}/${{ id }}\" Nested path fields \u00b6 If a field may contain / characters internally, they can be used to build paths: .gitsheets/content.toml [gitsheet] root = \"content\" path = \"${{ path/** }}\"","title":"Path templates"},{"location":"path-templates/#path-templates","text":"Path templates are the key to how Gitsheets works. They define how each sheet maps records into a tree of files. In addition to teaching Gitsheets how to store records, path templates also inform how they are queried. Gitsheets attempts to load as little of the tree as possible while executing a query by rendering the path from left to right against the query. This means that essentially, your path template is also your indexing and sharding strategy. This has little practical performance implication for sets of records in the 10s and 100s, but can become significant beyond that.","title":"Path templates"},{"location":"path-templates/#single-field-unique-key","text":"The simplest case is one where each record already has a single unique text field. .gitsheets/users.toml [gitsheet] root = \"users\" path = \"${{ username }}\" users/GrandmaCOBOL.toml first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"users\" path = \"${{ username }}\"' > .gitsheets/users.toml Upsert a user: git sheet upsert users '{ \"username\": \"GrandmaCOBOL\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }' Query a user: git sheet query users --filter.username = GrandmaCOBOL","title":"Single-field unique key"},{"location":"path-templates/#multi-field-unique-key","text":"If one field is not enough to create a unique path, a composite key can be configured by combining multiple path components: .gitsheets/domain-users.toml [gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\" domain-users/af.mil/GrandmaCOBOL.toml domain = \"af.mil\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" domain-users/yale.edu/GrandmaCOBOL.toml domain = \"yale.edu\" first_name = \"Grace\" last_name = \"Hopper\" username = \"GrandmaCOBOL\" Try it Declare the domain-users sheet: mkdir -p .gitsheets/ echo '[gitsheet] root = \"domain-users\" path = \"${{ domain }}/${{ username }}\"' > .gitsheets/domain-users.toml Upsert multiple users: git sheet upsert domain-users '[ { \"username\": \"GrandmaCOBOL\", \"domain\": \"yale.edu\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" }, { \"username\": \"GrandmaCOBOL\", \"domain\": \"af.mil\", \"first_name\": \"Grace\", \"last_name\": \"Hopper\" } ]' Query multiple users: git sheet query users --filter.username = GrandmaCOBOL Query unique user by domain: git sheet query users --filter.username = GrandmaCOBOL --filter.domain = af.mil","title":"Multi-field unique key"},{"location":"path-templates/#sharding-paths","text":"Path components need not contribute to the path\u2019s uniqueness, the can also be used just to organize records either for easier human browsing or to spread the records over multiple subtrees for improved query performance. Smaller trees can be loaded and searched faster, and any fields you\u2019re likely to often filter queries with can be acted on without loading and parsing the record if they\u2019re part of the path: .gitsheets/students.toml [gitsheet] root = \"students\" path = \"${{ graduation_year }}/${{ status }}/${{ student_id }}\"","title":"Sharding paths"},{"location":"path-templates/#dynamically-sharding-paths","text":"Because TOML has an explicit date type, and arbitrary JavaScript expressions can be used in path templates, you can do something like this to organize records by date: .gitsheets/blog-posts.toml [gitsheet] root = \"blog-posts\" path = \"${{ published_at.getYear() }}/${{ published_at.getMonth() }}/${{ published_at.getDate() }}/${{ slug }}\"","title":"Dynamically sharding paths"},{"location":"path-templates/#annotated-paths","text":"Prefixes, suffixes, and static path components can be used to add clarity for human readers: .gitsheets/todos.toml [gitsheet] root = \"todos\" path = \"by-user/user-${{ userId }}/${{ id }}\"","title":"Annotated paths"},{"location":"path-templates/#nested-path-fields","text":"If a field may contain / characters internally, they can be used to build paths: .gitsheets/content.toml [gitsheet] root = \"content\" path = \"${{ path/** }}\"","title":"Nested path fields"},{"location":"quick-demo/","text":"Quick demo \u00b6 Install the git sheet command \u00b6 npm install -g gitsheets Initialize a temporary git repository \u00b6 git init /tmp/gitsheets-demo cd /tmp/gitsheets-demo Declare a todos gitsheet \u00b6 mkdir -p .gitsheets echo -e '[gitsheet] root = \"todos\" path = \"user-${{ userId }}/${{ id }}\" ' > .gitsheets/todos.toml git add .gitsheets git commit -m \"feat: declare todos gitsheet\" Upsert records from an API \u00b6 curl https://jsonplaceholder.typicode.com/todos | git sheet upsert todos git commit -m \"data: import todos from API\" Query records via CLI \u00b6 git sheet query todos --filter.completed --format=csv > todos.completed.csv","title":"Quick demo"},{"location":"quick-demo/#quick-demo","text":"","title":"Quick demo"},{"location":"quick-demo/#install-the-git-sheet-command","text":"npm install -g gitsheets","title":"Install the git sheet command"},{"location":"quick-demo/#initialize-a-temporary-git-repository","text":"git init /tmp/gitsheets-demo cd /tmp/gitsheets-demo","title":"Initialize a temporary git repository"},{"location":"quick-demo/#declare-a-todos-gitsheet","text":"mkdir -p .gitsheets echo -e '[gitsheet] root = \"todos\" path = \"user-${{ userId }}/${{ id }}\" ' > .gitsheets/todos.toml git add .gitsheets git commit -m \"feat: declare todos gitsheet\"","title":"Declare a todos gitsheet"},{"location":"quick-demo/#upsert-records-from-an-api","text":"curl https://jsonplaceholder.typicode.com/todos | git sheet upsert todos git commit -m \"data: import todos from API\"","title":"Upsert records from an API"},{"location":"quick-demo/#query-records-via-cli","text":"git sheet query todos --filter.completed --format=csv > todos.completed.csv","title":"Query records via CLI"},{"location":"cli/","text":"Getting started \u00b6 npm install -g gitsheets-cli Or with Chef Habitat: hab pkg install jarvus/gitsheets","title":"Getting started"},{"location":"cli/#getting-started","text":"npm install -g gitsheets-cli Or with Chef Habitat: hab pkg install jarvus/gitsheets","title":"Getting started"},{"location":"nodejs/","text":"Getting started \u00b6 npm install --save gitsheets","title":"Getting started"},{"location":"nodejs/#getting-started","text":"npm install --save gitsheets","title":"Getting started"}]}